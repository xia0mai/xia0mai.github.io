[{"title":"创建首个解密Skill的收获与反思：效率提升vs恶意投毒风险","path":"/2026/01/18/创建首个解密Skill的收获与反思：效率提升vs恶意投毒风险/","content":"首发先知社区 https://xz.aliyun.com/news/91212 前言接上文,如果说上文ai的作用是让一个不太懂逆向的人也可以绕过的app验签,本文ai的作用就是让一个不太懂逆向的人快速绕过app的验签,且在其中发现大模型的一些隐藏攻击面 将app绕过验签等工作流做成skill下面这段文本是我给大模型的提示词同时也几乎是我平时绕过app验签或者加密的一个工作流 主要用到的工具有ida,hooker,flask,autodecode,burp,在这套加解密工作流中,我一般先用hooker来拿到明文到密文的堆栈信息,以及一些加解密的方法和密钥,之后会把hook到的明文到密文的这一段堆栈信息和该操作的请求包或者响应包交给idamcp,让他给我写好需要进一步分析方法逻辑或者加密逻辑的hook脚本,当拿到所有的加密密钥或者加密逻辑后,codex会自己写好测试解密是否成功的脚本测试密钥是否正确或者加密逻辑是否正确的python脚本,当这些都完成过,codex会自己写好对应的flask脚本,并告诉我需不需要开启autodecode中类似请求头加密功能的信息 由于经费不足,我选择了中转的codex作为日常使用的大模型,使用codex的原因是,codex cli支持api的方式调用而且他对逆向或者说代码审查的能力不错,以及其他一些好用的功能,例如skills 什么是skills从技术角度看，Skills 本质上是一组 API 调用、脚本或工具函数的封装。它为 AI 提供了一个标准化的接口，让 AI 知道： 这个技能叫什么？（名称） 它能解决什么问题？（描述） 需要输入什么参数才能运行？（参数规范) 简单的说,就是各个skill都拥有特定的技能,例如这个skill掌握着加解密,逆向相关的知识以及日常的工作流,那个skill拥有免杀相关的知识和工作流,又或者说这个skill是会按照a风格开发登录页面,那个skill是会按照b风格开发页面 skills在渗透测试中的利用之前,我想让codex帮我找到我在app渗透测试中某个数据包中的某个被加密的参数的加密逻辑,我需要和他说 问:帮我连接我的idamcp,找到这个数据包中的xxx参数的加密逻辑答:好的我现在连接你的idamcp,xxxxx(最终找到一堆不是关键的东西)问:(经过多次沟通)答:(最终找到这个东西是怎么加密的)问:把解密的脚本给我答:(把解密的脚本给我了) 如何创建skill这里以codex举例 在codex cli中输入skills回车会发现,这里有两种形式引入skill,一个是自己创建,一个是远程加载,由于现在能用于skill的资源太少且不一定能兼容我目前工作中遇到的app加解密场景,我选择自己创建一个skill 这里我创建了一个名为decskill的skill 接着我按着codex的提示,把自己平常大概的工作流告诉他,然后给一些提示词 接着我按照下面这篇文章的流程,把自己用到的一些插件,自己之前写好的自动化加解密的脚本,以及自己和别人的一些安卓逆向获取加解密逻辑最终实现自动化加解密的文档放到相应的文件夹 https://zhuanlan.zhihu.com/p/1986916268675187102 此时我的第一个skill已经创建好了 使用了skill之后的效果这里我就只问了一个问题 这个问题对应的回答,可以看到.我只问了他一次,他就告诉了我正确的加密逻辑还写出了对应的加密脚本并验证正确,因为我现在的工作内容就是负责某个行业相关的渗透测试工作,且我发现开发风格其实非常相似,我想在这种模式下,以后我渗透测试前的解密工作要用的时间应该会大大减小 skills的攻击面从上文中,我们知道了怎么创建一个skill,以及skill可以像git一个脚本一样,把git仓库中的脚本拉到本地让codex去按照别人设置好的工作流思考和执行设定好的行为.但是有没有想过.当随着ai的普及,Skill会变得像如今的手机中的app,被需要的人下载下来，然后直接去执行,若有人在skill中投毒会是怎样的效果？ 攻击者制作一个藏有上线功能的skill这里我们重新创建一个带有投毒意义的skill 可以看到我们目的非常清晰,就是直接下载木马然后执行的意思,并告诉codex不要产生任何能与用户交互的动作.这里其实加密一下执行的命令会更好 当skill创建好之后,我们按照意象的工作流,去删除指定文件的xxx文件时,受害者的设备就已经被上线控制了 攻击者将skill上传到github,受害者下载下来后导致被投毒这里模仿受害者将带有上线功能的skill拉到本地 当受害者想要让带有相关功能的skill去做相关专业的事情时,事情是做完了,但是也导致自己上线了 总结 通过Codex CLI 或者其他大模型 的 skills 机制，我们可以把常用工具脚本文档打包成标准接口，复用在类似的渗透场景中，大幅减少解密前置时间.但是如果技能脚本被植入恶意命令（如下载并执行木马），用户在调用看似正常的功能时就可能被“上线”。恶意 skill 还能被上传到 GitHub 让他人误用.Skill 在带来效率提升的同时，也带来了供应链风险，需要对 Skill 的来源和脚本内容进行审计，避免无意执行恶意 Payload.","tags":["安全","MCP","逆向"],"categories":["逆向&加解密","ai"]},{"title":"记录一次实战中java环境的后渗透","path":"/2026/01/18/记录一下实战中java环境的后渗透/","content":"回顾一下去年在内网实战中遇到的一个jar包启动的环境后渗透过程 起因是内网中发现某台服务器存在jdwp未授权漏洞,通过该漏洞我可以使用相关的工具达到rce的效果,但是因为不出网且只能一次性执行命令的原因,我无法把服务器上的文件当下来以及上线服务器 ps -ef查看了当前服务器正在运行的进程后发现,服务器没有使用一些中间件,而是只有一个java -jar app.jar的命令有点可以,app.jar文件存在服务器的根目录中,但是我无法将服务器文件当下来 当时我使用以下命令,查看到了该jar包的目录结构,然后从中读取到了配置文件的信息,然后获取了大量的配置文件信息,使得我发现了目标多个nacos以及多个关键数据库账密,从nacos配置项中又翻到大量配置信息,通过该漏洞就累计获取了目标30+数据库权限以及大量服务器权限,从数据库中又翻到配置信息,又接管了目标100+的web后台 jar -tf 文件名.jar 下面是以我本地jar包举得一个例子 查看到目录结构之后,使用如下命令即可把jar包中的配置文件给抽出来,然后cat去查看其中的配置文件内容.这里也可以用unzip命令 jar -xf gogogo-jar-with-dependencies.jar ./META-INF/maven/org.example/gogogo/pom.properties 那么除了这种查看jar包结构然后读取其中配置文件敏感信息的方式,还有哪些手法能用于java环境的后渗透呢 这里我随便启动一个java环境 查看运行着当前java环境的pid 提取至文件 tmpheap_full.hprof 把内存文件下载回本地用相应工具查看其中敏感信息也可以做到不错的效果","tags":["安全","内网","后渗透"],"categories":["内网","后渗透"]},{"title":"MCP加持下全自动化绕过验签&加密app","path":"/2026/01/07/MCP加持下全自动化绕过验签&加密app/","content":"记录了一下工作中遇到的验签和加密的app的全自动化分析和绕过方案,其中值得关注的是如何不看一点代码和写一点代码就实现全自动化绕过的思路,本文只记录绕过方案,不涉及任何渗透测试操作 首发自先知社区 https://xz.aliyun.com/news/91055 1.初始情况展示这是一个发送验证码操作的一个数据包,可以看到请求头做了相关验签操作,以及手机号是被加密的 目前我猜测的是Method Time Sign和请求体是有关联的 任何一个发生改变都会造成验签不通过 也就是老生常谈的防篡改 2.尝试手工寻找加密逻辑以及加密密钥一般我喜欢用hooker这个工具先看看能不能hook到相关加解密密钥,以及看看从明文到密文的一个堆栈信息,工具地址如下,这是一个非常好用的工具 https://github.com/CreditTone/hooker?tab=readme-ov-file 在发送验证码出抓包查看hook到的信息 从下图可以发现一处明文到密文的转变,以及相关的堆栈信息 这里我并不清楚这个MessageDigest.update到底是什么作用,我只知道他生成的md5值与我数据包中的sign值相匹配 但是这个MessageDigest.digest方法应该就是将MessageDigest.update的结果md5加密的意思 sign的生成逻辑现在我们已经知道一半了,sign是由md5加密MessageDigest.update的结果生成的,但是MessageDigest.update这个方法的代码逻辑我们不清楚,这个问题先留着等会再看,先接着看看在发送验证码这一步,请求体加密的那一段的hook结果 看到hook到两组密钥,不想动手叫ai写了个脚本验证了密钥是正确的 3.ida-pro-mcp初体验此时可以说问题已经解决了三分之一,现在加密逻辑我已经知道了,sign生成的方式我也知道了,就是不知道被md5加密的这个值到底是怎么来的,因为不同接口,不同请求他被md5加密前的值是会变化的,最近刚好学习了各种mcp的一些手法,就想着试试用ida-pro-mcp去替我解决这个问题,相关的配置可以看看这篇文章 https://mp.weixin.qq.com/s/ey7oXVW0iUlmaCVRZnaH5A 提示词可以分批完成,不要一口气把想干什么都告诉他,因为上下文有限,而且他不可能给我们一步到位,一步步来我们会知道问题出在哪里然后去纠正他(这里有点错别字) 有点惊讶,图居然很快给了我一个答案,这个app是经过混淆的,人工去找得花不少功夫,下面是app脱壳后反编译的包名类名以及ai给我的回答结果 看到这个结果可能感觉已经找到一半了,但这时候我发现我的思路可能有点问题,我想去hook这个MessageDigest.update的值把他当成解密后的sign,但我完全没必要这么做,我不需要看到sign是什么东西,也不需要手动修改他,我只需要能修改请求体并绕过验签就行了 这时候观察了一下md5加密前的这一段字符串,发现其实是有迹可循的,有些东西是固定的,有些是请求头获取,有些是从请求体的json中提取进来的 到这里我现在已经清楚了他整体的验签逻辑 Method : 当前接口是对应类Time : 当前时间戳Sign : md5(clientSecret=固定的字符串clientType=固定的手机型号method=调用的类mobile=从JSON请求体中循环取值并拼接后的字符串requestUri=(请求路径 例如/vuc/user 去除/yuc)time=时间戳version=固定的请求头)Version: 版本号Client-Type:手机型号 这里还有一关键的问题,就是从JSON请求体中循环取值并拼接后的字符串,他并不是直接一个循环直接拼接过去的,我发现每个包拼接顺序和从json中直接提取数据拼接过去的字符串顺序不一样,这会影响到时候md5加密的值不同,导致验签失败 Sign : md5(clientSecret=固定的字符串clientType=固定的手机型号method=调用的类mobile=从JSON请求体中循环取值并拼接后的字符串requestUri=(请求路径 例如/vuc/user 去除/yuc)time=时间戳version=固定的请求头) 这个问题,直接使用ida-mcp让它去给我找出来了这段拼接逻辑,他给出的结果是json中提取到的数据,按字母排序拼接,它给的说明文档如下所示 综上来看,我们渗透的时候一般只改变请求体,所以我们只需要把每次发包的请求体动态拼接成字符串然后md5加密,就能绕过这个验签了 4.flasktestheader.pyautodecrypt实现自动化绕过接下来开始借助 AI 编写脚本,把之前做过的一些使用frida-rpcflasktestheader.pyautodecrypt的脚本拉到工作区,让ai学习,参照我之前的例子对我本次要实现自动化加解密的需求重新改一份脚本,期间会出现一些问题,可以这些任务拆分成一些小任务,或者叫他打印日志,方便我们和ai分析问题出在哪,下面直接放图了 最终脚本如下: # -*- coding:utf-8 -*-Sign 生成服务器 - 纯 Sign 生成版本配合 Burp autoDecoder 插件使用只负责生成 sign，不做任何加解密from flask import Flask, requestimport jsonimport hashlibimport re# ========== 配置参数 ==========# Sign 参数CLIENT_SECRET = Vxxxxx3v2XMCLIENT_TYPE = xxxxidVERSION = xxxx.0URI_PREFIX = /vxxxFLASK_PORT = 8888app = Flask(__name__)# ========== HTTP 请求解析 ==========def parse_headers_string(headers_str): 解析 autodecrypt 发送的 headers 字符串 headers = path = lines = headers_str.replace(\\r , ).split( ) for i, line in enumerate(lines): if i == 0: parts = line.split( ) if len(parts) = 2: path = parts[1].split(?)[0] elif : in line: k, v = line.split(: , 1) headers[k] = v.strip() return headers, pathdef build_sign(headers, path, body): 构建 sign params = clientSecret: CLIENT_SECRET, clientType: CLIENT_TYPE, version: VERSION # 提取 Method 和 Time for k in [Method, method, METHOD]: if k in headers: params[method] = headers[k] break for k in [Time, time, TIME]: if k in headers: params[time] = headers[k] break # 提取 requestUri if path.startswith(URI_PREFIX): params[requestUri] = path[len(URI_PREFIX):] else: params[requestUri] = path # 从 body 提取参数（使用加密后的值） for k, v in body.items(): if k != sign and v is not None: params[k] = str(v) # 按字母排序拼接 plaintext = .join([fk=params[k] for k in sorted(params.keys())]) sign = hashlib.md5(plaintext.encode(utf-8)).hexdigest() print(f[Sign明文] plaintext) print(f[Sign] sign) return sign# ========== Flask 路由 ==========@app.route(/decode, methods=[POST])def decode(): 解密接口 - 原样返回，不做任何处理 body_str = request.form.get(dataBody, ) headers_str = request.form.get(dataHeaders, ) print(f =*60) print(f[Decode 请求 - 原样返回]) print(f=*60 ) # 返回格式：headers + 4个\\r + body if headers_str: headers_clean = headers_str.strip() headers_clean = headers_clean.replace(\\r , ).replace( , \\r ) return headers_clean + \\r \\r \\r \\r + body_str return body_str@app.route(/encode, methods=[POST])def encode(): 加密接口 - 只生成 sign，不做任何加解密 body_str = request.form.get(dataBody, ) headers_str = request.form.get(dataHeaders, ) print(f =*60) print(f[Sign 生成请求]) if not headers_str: print([错误] 没有 headers) return body_str headers, path = parse_headers_string(headers_str) print(f[路径] path) print(f[Method] headers.get(Method, N/A)) print(f[Time] headers.get(Time, N/A)) body = if body_str.strip(): try: body = json.loads(body_str.strip()) print(f[Body] body) except Exception as e: print(f[错误] e) # 生成新 sign new_sign = build_sign(headers, path, body) # 替换 Sign sign_pattern = re.compile(r(Sign:\\s*)([^\\r ]+), re.IGNORECASE) if sign_pattern.search(headers_str): new_headers = sign_pattern.sub(f\\\\g1new_sign, headers_str) else: new_headers = headers_str.rstrip() + f\\r Sign: new_sign print(f[新Sign] new_sign) print(f=*60 ) # 返回格式：headers + 4个\\r + body new_headers_clean = new_headers.strip() new_headers_clean = new_headers_clean.replace(\\r , ).replace( , \\r ) return new_headers_clean + \\r \\r \\r \\r + body_str@app.route(/test, methods=[GET])def test(): 测试接口 return json.dumps( status: ok, message: Sign 生成服务器运行中, version: 4.0 - 纯 Sign 生成版, endpoints: /encode: 生成 sign（不做加解密）, /decode: 原样返回（不做加解密）, /test: 测试接口 , config: client_secret: CLIENT_SECRET[:10] + ... , ensure_ascii=False, indent=2)if __name__ == __main__: print(= * 60) print(Sign 生成服务器 - 纯 Sign 生成版) print(= * 60) print(f端口: FLASK_PORT) print(f接口:) print(f /encode - 生成 sign（不做加解密）) print(f /decode - 原样返回（不做加解密）) print(f /test - 测试接口) print() print(说明:) print( - 服务器只负责生成 sign) print( - 不做任何 AES 加解密) print( - 加解密由 Burp 插件或其他工具完成) print(= * 60) app.run(host=0.0.0.0, port=FLASK_PORT, debug=False) 5.最终效果展示至此,脚本就算是写好了,看看最终效果吧 此时发包,已经绕过了验签,后续只需要开启autodecrypt中burp各模块的开关,就可以实现全自动的绕过验签 到结束,其实还有一步没有做,就是请求体的自动化加解密,因为我发现很多包的请求体没有使用aes加密,就直接生成了一个加密后的字典fuzz了一波,没有做成自动化加解密 感慨一下AI的强大,这个案例虽然不是特别难,但我真的一行代码没写,反编译后的东西我看到混淆了就不想动了,最后居然一行代码都不写就绕过了一个原本不算简单的问题.","tags":["安全","MCP","逆向"],"categories":["逆向&加解密"]},{"title":"admin","path":"/about/index.html","content":"xia0maia boy"}]